/* ****************************************************************
 * Athr(s): Harry Direen PhD,
 * DireenTech Inc.  (www.DireenTech.com)
 * Date: May 30, 2018
 *
 * Vehicle Actuator CAN Bus Interface Manager
 * The CAN interface needs to be started ... before Videre... see
 * https://elinux.org/Bringing_CAN_interface_up
 *      ifconfig -a should show can bus and id: can0
 *      sudo ip link set can0 type can bitrate 250000    The KarTech and EPAS system run at 250kBaud
 *      sudo ip link set up can0
 *
 * Uses SocketCAN:  http://blog.mbedded.ninja/programming/operating-systems/linux/how-to-use-socketcan-with-c-in-linux
 * https://www.kernel.org/doc/Documentation/networking/can.txt
 * https://github.com/linux-can/can-utils
 * Ties into the Linux input system: /dev/input/eventx
 *******************************************************************/

#ifndef VIDERE_DEV_VEHICLEACTUATORINTERFACEMANAGER_H
#define VIDERE_DEV_VEHICLEACTUATORINTERFACEMANAGER_H

#include <iostream>
#include <string>
#include <memory>
#include <vector>
#include <sstream>
#include <thread>
#include <unordered_map>
#include <RabitManager.h>
#include <RabitStopWatch.h>
#include <RabitMessageQueue.h>
#include <ManagerStatusMessage.h>
#include <ManagerControlMessage.h>
#include <ManagerStats.h>
#include <ManagerStatusMessage.h>
#include "global_defines.h"
#include "all_manager_message.h"
#include "../../Utils/config_data.h"
#include "../../Utils/logger.h"
#include "../../Utils/timing.h"
#include <linux/can.h>
#include "KarTechLinearActuator.h"
#include "DceEpasSteeringInterface.h"
#include "SipnPuffMessage.h"
#include "DataRecorder.h"
#include "DataLogReader.h"
#include "KarTechLADataRecords.h"
#include "EpasSteeringDataRecords.h"
#include "DataRecorderStdHeader.h"

// Manually include this file that has been autogenerated
#include "VehicleActuatorInterfaceManagerWSRMgr.h"

using namespace Rabit;

namespace videre
{
    class VehicleActuatorInterfaceManager : public VehicleActuatorInterfaceManagerWSRMgr
    {
    private:
        //Logging System
        log4cxx::LoggerPtr log4cpp_;

        std::shared_ptr<ConfigData> _config_sptr;

        int _canSocketHandle = -1;

        //EPAS Steering System CAN IDs
        uint32_t _epasSteeringTorqueReportID = 0x0290;
        uint32_t _epasSteeringAngleReportID = 0x0292;
        uint32_t _epasSteeringControlID = 0x0296;

        uint32_t _brakeActuatorStateCntr = 0;
        uint32_t _throttleActuatorStateCntr = 0;
        uint32_t _steeringStateCntr = 0;

        KarTechLinearActuator _brakeActuator;
        KarTechLinearActuator _throttleActuator;

        DceEpasSteeringInterface _steeringControl;

        DataRecorder _canRxDataRecorder;
        DataRecorder _canTxDataRecorder;

        DataLogReader _canRxDataLogReader;

        DataRecorderStdHeader _dataRecorderCanRxHeader;
        DataRecorderStdHeader _dataRecorderCanTxHeader;

        KarTechLACommandDataRecord _brakePosCtrlRecord;
        KarTechLACommandDataRecord _throttlePosCtrlRecord;

        EpasSteeringCommandDataRecord _steeringCommandDataRecord;

        bool EnableSteeringLogging = true;
        bool EnableBrakeLogging = true;
        bool EnableThrottleLogging = true;

        //Messages
        std::shared_ptr<SipnPuffMessage> _sipnPuffMsg;

        std::shared_ptr<ImageLoggingControlMessage> _loggingControlMsg;

        std::shared_ptr<LinearActuatorPositionCtrlMessage> _brakePositionControlOutpMsg;
        std::shared_ptr<LinearActuatorPositionCtrlMessage> _throttlePositionControlOutpMsg;

        std::thread _backgroundRxThread;
        bool _backgroundRxThreadIsRunning = false;

        bool _shutdown = false;

        struct can_frame _rxCanFame;
        struct can_frame _txCanFame;
        struct can_frame _txBrakeCanFame;
        struct can_frame _txThrottleCanFame;
        struct can_frame _txSteeringCanFame;

        uint32_t _msgCntr = 0;

        RabitStopWatch _ctrlStopwatch;

    public:
        VehicleActuatorInterfaceManager(std::string name, std::shared_ptr<ConfigData> config);

        virtual void Initialize();

        //Send KarTech Parameters to the Actuator if they are not equal to the
        //current parameter values provided in CurrentLinearActuatorParamsMsg;
        void sendKarTechParametetersToActuator(std::shared_ptr<KarTechLinearActuatorParamsMessage> LinearActuatorParamsMsg,
                                               std::shared_ptr<KarTechLinearActuatorParamsMessage> CurrentLinearActuatorParamsMsg,
                                               bool forceSendAll = true);

        void setBrakeActuatorPostion();

        void setThrottleActuatorPostion();

        void setSteeringControlTorque();

        void testActuatorControl();

        virtual void Startup() final;

        virtual void ExecuteUnitOfWork() final;

        virtual void Shutdown() final;

        bool sendCanMessage(struct can_frame &txCanMsg);

        //The CAN receive process will be handled in a separate
        //thread.  This keeps the blocking recieve function from
        //stopping the primary process.
        void receiveCanMessagesThread();
    };

}
#endif //VIDERE_DEV_VEHICLEACTUATORINTERFACEMANAGER_H
