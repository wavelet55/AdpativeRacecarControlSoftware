
@###############################################
@#
@# Rabit message generation for C++
@#
@# EmPy template for generating <msg>.cpp files
@#
@###############################################
@# Start of Template
@###############################################

/* ****************************************************************
  *******************************************************************/

/* Auto-generated by genmsg_cpp from file @file_name_in, do not modify directly */

@{
import genmsg.msgs
from rabit_msg_helper import *

msg_name = spec.short_name
}@

#include "@(msg_name).h"
#include <ByteArrayReaderWriter.h>
#include <sstream>

//ToDo Add Flag for enabling an disabling FastDDS Serialization
#include <fastcdr/Cdr.h>


using namespace Rabit;
using namespace std;

@{

################################################################
#                    Function Templates
################################################################

string_copy_template = """
    void {}::CopyTo{}(string s){{
        int L = s.length();
        int CL = {};

        fill(std::begin({}), std::end({}), 0);

        int M = L < CL ? L : CL;

        for( int m = 0; m < M; m++ ){{
            {}[m] = s[m];
        }}
    }}

    void {}::CopyTo{}(char* c, int L){{
         int CL = {};

         fill(std::begin({}), std::end({}), 0);

         int M = L < CL ? L : CL;

         for( int m = 0; m < M; m++ ){{
             {}[m] = c[m];
         }}
    }}

"""

################################################################
# python functions for filling in parts of the template
################################################################
def clone_variables(fields):
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                print("        clone->{} = this->{};".format(str(field.name), str(field.name)))
            else:
                print("        clone->{} = this->{};".format(str(field.name), str(field.name)))
        else:
                print("not here")

def copy_variables(fields):
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                print("            this->{} = static_cast<{}*>(msg)->{};".format(str(field.name), msg_name , str(field.name)))
            else:
                print("            this->{} = static_cast<{}*>(msg)->{};".format(str(field.name), msg_name ,str(field.name)))
        else:
                print("not here")

def clear_variables(fields):
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                if field.type == "string":
                    print("        {}.clear();".format(str(field.name)))
                else:
                    print("        {} = 0;".format(str(field.name)))
            else:
                print("        std::fill( std::begin({}), std::end({}), 0 );".format(str(field.name), str(field.name)))
        else:
                print("not here")

def string_variables(fields):
    print("        ss << \"[\";")
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                print("        ss << \"{} = \" << {} << \", \";".format(str(field.name), str(field.name)))
            else:
                print("        ss << \"{} = [\";".format(str(field.name)))
                print("        for(int i: {}){{ ss << i << \", \";  }}".format(str(field.name)))
                print("        ss << \"], \";")
        else:
                print("not here")
    print("        ss << \"]\";")

def get_set_variables(fields):
    for field in fields:
            if (field.is_builtin):
                if (not field.is_array):
                    if field.type == "string":
                        pass
                    else:
                        pass
                else:
                    print(string_copy_template.format(msg_name, str(field.name),str(field.array_len),str(field.name),str(field.name),str(field.name),
                                                      msg_name, str(field.name),str(field.array_len),str(field.name),str(field.name),str(field.name)))

            else:
                    print("not here")

def serialize_variables(fields):
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                if field.type == "string":
                    print("            bw.write{}({}.c_str(), {}.length());".format(str(type_byte_writer_map[field.type]), str(field.name), str(field.name)))
                else:
                    print("            bw.write{}({});".format(str(type_byte_writer_map[field.type]), str(field.name)))
            else:
                print("            for(int n = 0; n < {}; n++){{".format(str(field.array_len)))
                print("                bw.write{}({}[n]);".format(str(type_byte_writer_map[field.base_type]), str(field.name)))
                print("            }")
        else:
            print("not here")

def serialize_fastdds_variables(fields):
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                print("            scdr << {};".format(str(field.name)))
            else:
                print("            for(int n = 0; n < {}; n++){{".format(str(field.array_len)))
                print("                scdr << {}[n];".format(str(field.name), str(field.name)))
                print("            }")
        else:
            print("not here")



def deserialize_variables(fields):
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                if field.type == "string":
                    print("            br.readString(&{});".format(str(field.name)))
                else:
                    print("            {} = br.read{}();".format(str(field.name), str(type_byte_writer_map[field.type]) ))
            else:
                print("            for(int n = 0; n < {}; n++){{".format(str(field.array_len)))
                print("                {}[n] = br.read{}();".format(str(field.name), str(type_byte_writer_map[field.base_type])))
                print("            }")
        else:
            print("not here")

def deserialize_fastdds_variables(fields):
    for field in fields:
        if (field.is_builtin):
            if (not field.is_array):
                print("            dcdr >> {};".format(str(field.name)))
            else:
                print("            for(int n = 0; n < {}; n++){{".format(str(field.array_len)))
                print("                dcdr >> {}[n];".format(str(field.name), str(field.name)))
                print("            }")
        else:
            print("not here")


}@
namespace @(nm_space)
{

    @(msg_name)::@(msg_name)() : Rabit::RabitMessage()
    {
        this->Clear();
    }

    std::unique_ptr<Rabit::RabitMessage> @(msg_name)::Clone() const
    {
        std::unique_ptr<@(msg_name)> clone = std::make_unique<@(msg_name)>();
        clone->CopyBase(this);
@clone_variables(spec.parsed_fields())
        return std::move(clone);
    }

    bool @(msg_name)::CopyMessage(Rabit::RabitMessage* msg)
    {
        if(msg->GetTypeIndex() == std::type_index(typeid(@(msg_name))))
        {
            Rabit::RabitMessage::CopyMessage(msg); // call baseclass
@copy_variables(spec.parsed_fields())
            return true;
        }
        return false;
    }

    void @(msg_name)::Clear()
    {
@clear_variables(spec.parsed_fields())
    }

    std::string @(msg_name)::ToString() const
    {
        std::ostringstream ss;
@string_variables(spec.parsed_fields())
        return ss.str();
    }

@get_set_variables(spec.parsed_fields())

    int @(msg_name)::Serialize(uint8_t *buf, int maxBufSize, int stype)
    {
        int noBytes = 0;
        if(stype < 2)
        {
            ByteArrayWriter bw(buf, maxBufSize, Rabit::EndianOrder_e::Endian_Big);
            if(stype == 0)
            {
                SerializeMsgHeader(bw);
            }
@serialize_variables(spec.parsed_fields())
            noBytes = bw.Idx;
        }
        else if(stype == 2)
        {
            eprosima::fastcdr::FastBuffer cdrbuffer((char *)buf, maxBufSize);
            eprosima::fastcdr::Cdr scdr(cdrbuffer,
                                        eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                                        eprosima::fastcdr::Cdr::CORBA_CDR);
            scdr.setDDSCdrPlFlag(eprosima::fastcdr::Cdr::DDS_CDR_WITHOUT_PL);
@serialize_fastdds_variables(spec.parsed_fields())
            noBytes = (int)scdr.getSerializedDataLength();
        }
        return noBytes;
    }

    int @(msg_name)::DeSerialize(uint8_t *buf, int len, int stype)
    {
        int noBytes = 0;
        if(stype < 2)
        {
            ByteArrayReader br(buf, len, Rabit::EndianOrder_e::Endian_Big);
            if(stype == 0)
            {
                DeSerializeMsgHeader(br);
            }
@deserialize_variables(spec.parsed_fields())
            noBytes = br.Idx;
        }
        else if(stype == 2)
        {
            eprosima::fastcdr::FastBuffer cdrbuffer((char *)buf, len);
            eprosima::fastcdr::Cdr dcdr(cdrbuffer,
                                        eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS,
                                        eprosima::fastcdr::Cdr::CORBA_CDR);
            dcdr.setDDSCdrPlFlag(eprosima::fastcdr::Cdr::DDS_CDR_WITHOUT_PL);
@deserialize_fastdds_variables(spec.parsed_fields())
            noBytes = (int)dcdr.getSerializedDataLength();
        }
        return noBytes;
    }


}